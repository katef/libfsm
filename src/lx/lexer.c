/* Generated by lx */

#include <assert.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <errno.h>

#include LX_HEADER

static enum lx_token z0(struct lx *lx);
static enum lx_token z1(struct lx *lx);
static enum lx_token z2(struct lx *lx);
static enum lx_token z3(struct lx *lx);
static enum lx_token z4(struct lx *lx);

static int
lx_advance_end(struct lx *lx, int c)
{
	lx->end.byte++;
	lx->end.col++;
	if (c == '\n') {
		lx->end.line++;
		lx->end.saved_col = lx->end.col - 1;
		lx->end.col = 1;
	}
	if (lx->push != NULL) {
		if (-1 == lx->push(lx->buf_opaque, (char)c)) {
			return 0;
		}
	}
	return 1;
}

/* This wrapper manages one character of lookahead/pushback
 * and the line, column, and byte offsets. */
#if __STDC_VERSION__ >= 199901L
inline
#endif
static int
lx_getc(struct lx *lx)
{
	int c;

	assert(lx != NULL);
	assert(lx->lgetc != NULL);

	if (lx->c != EOF) {
		c = lx->c, lx->c = EOF;
	} else {
		c = lx->lgetc(lx);
		if (c == EOF) {
			return EOF;
		}
	}

	if (!lx_advance_end(lx, c)) { return EOF; }

	return c;
}

/* This wrapper adapts calling lx_getc to the interface
 * in libfsm's generated code. */
static int
fsm_getc(void *getc_opaque)
{
	return lx_getc((struct lx *)getc_opaque);
}

#if __STDC_VERSION__ >= 199901L
inline
#endif
static void
lx_ungetc(struct lx *lx, int c)
{
	assert(lx != NULL);
	assert(lx->c == EOF);
	lx->c = c;
	lx->end.byte--;
	lx->end.col--;

	if (c == '\n') {
		lx->end.line--;
		lx->end.col = lx->end.saved_col;
	}
}

/* Get a character from fgetc and push it to the buffer */
int
lx_fgetc(struct lx *lx)
{
	assert(lx != NULL);
	assert(lx->getc_opaque != NULL);

	const int c = fgetc(lx->getc_opaque);
	if (c == EOF) {
		lx->c = EOF;
		return EOF;
	} else {
		return c;
	}
}

int
lx_dynpush(void *buf_opaque, char c)
{
	struct lx_dynbuf *t = buf_opaque;

	assert(t != NULL);

	if (t->a == NULL || t->p == t->a + t->len) {
		size_t len;
		ptrdiff_t off;
		char *tmp;

		if (t->len == 0) {
			assert(LX_DYN_LOW > 0);
			len = LX_DYN_LOW;
		} else {
			len = t->len * LX_DYN_FACTOR;
			if (len < t->len) {
				errno = ERANGE;
				return -1;
			}
		}

		off = t->p - t->a;
		tmp = realloc(t->a, len);
		if (tmp == NULL) {
			return -1;
		}

		t->p   = tmp + off;
		t->a   = tmp;
		t->len = len;
	}

	assert(t->p != NULL);
	assert(t->a != NULL);

	*t->p++ = c;

	return 0;
}

static void
lx_dynpop(void *buf_opaque)
{
	struct lx_dynbuf *t = buf_opaque;

	assert(t != NULL);

	assert(t->p != t->a);
	t->p--;
}

int
lx_dynclear(void *buf_opaque)
{
	struct lx_dynbuf *t = buf_opaque;

	assert(t != NULL);

	if (t->len > LX_DYN_HIGH) {
		size_t len;
		char *tmp;

		len = t->len / LX_DYN_FACTOR;

		tmp = realloc(t->a, len);
		if (tmp == NULL) {
			return -1;
		}

		t->a   = tmp;
		t->len = len;
	}

	t->p = t->a;

	return 0;
}

void
lx_dynfree(void *buf_opaque)
{
	struct lx_dynbuf *t = buf_opaque;

	assert(t != NULL);

	free(t->a);
}
static enum lx_token
z0(struct lx *lx)
{
	int has_consumed_input = 0;
	int c;

	assert(lx != NULL);

	if (lx->clear != NULL) {
		lx->clear(lx->buf_opaque);
	}

	lx->start = lx->end;

	void *getc_opaque = (void *)lx;
	enum {
		S0, S1, S2
	} state;

	state = S0;

	while (c = fsm_getc(getc_opaque), c != EOF) {
		has_consumed_input = 1;
		switch (state) {
		case S0: /* e.g. "" */
			switch ((unsigned char) c) {
			case '/': state = S2; break;
			default: state = S1; break;
			}
			break;

		case S1: /* e.g. "" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_CHAR;

		case S2: /* e.g. "\057" */
			switch ((unsigned char) c) {
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z': break;
			default:  lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return lx->z = z4, TOK_RE;
			}
			break;

		default:
			; /* unreached */
		}
	}

	/* end states */
	switch (state) {
	case S1: return TOK_CHAR;
	case S2: return lx->z = z4, TOK_RE;
	default: 
				if (!has_consumed_input) { return TOK_EOF; }
				lx_ungetc(lx, c); lx->lgetc = NULL; return TOK_UNKNOWN;
	}

		if (lx->push != NULL) {
			if (-1 == lx->push(lx->buf_opaque, (char)c)) {
				return TOK_ERROR;
			}
		}

	lx->lgetc = NULL;

	if (!has_consumed_input) {
		return TOK_EOF;
	} 
	return TOK_ERROR;
}

static enum lx_token
z1(struct lx *lx)
{
	int has_consumed_input = 0;
	int c;

	assert(lx != NULL);

	if (lx->clear != NULL) {
		lx->clear(lx->buf_opaque);
	}

	lx->start = lx->end;

	void *getc_opaque = (void *)lx;
	enum {
		S0, S1, S2, S3, S4, S5, S6, S7
	} state;

	state = S0;

	while (c = fsm_getc(getc_opaque), c != EOF) {
		has_consumed_input = 1;
		switch (state) {
		case S0: /* e.g. "" */
			switch ((unsigned char) c) {
			case '\\': state = S1; break;
			case '"': state = S3; break;
			default: state = S2; break;
			}
			break;

		case S1: /* e.g. "\\" */
			switch ((unsigned char) c) {
			case 'x': state = S4; break;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7': state = S5; break;
			case '"':
			case '\\':
			case 'f':
			case 'n':
			case 'r':
			case 't':
			case 'v': state = S6; break;
			default:  lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_CHAR;
			}
			break;

		case S2: /* e.g. "\\x00" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_CHAR;

		case S3: /* e.g. "\"" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return lx->z = z4, TOK_STR;

		case S4: /* e.g. "\\x" */
			switch ((unsigned char) c) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f': state = S7; break;
			default:  
				if (!has_consumed_input) { return TOK_EOF; }
				lx_ungetc(lx, c); lx->lgetc = NULL; return TOK_UNKNOWN;
			}
			break;

		case S5: /* e.g. "\\0" */
			switch ((unsigned char) c) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7': break;
			default:  lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_OCT;
			}
			break;

		case S6: /* e.g. "\\\"" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_ESC;

		case S7: /* e.g. "\\x0" */
			switch ((unsigned char) c) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f': break;
			default:  lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_HEX;
			}
			break;

		default:
			; /* unreached */
		}
	}

	/* end states */
	switch (state) {
	case S1: return TOK_CHAR;
	case S2: return TOK_CHAR;
	case S3: return lx->z = z4, TOK_STR;
	case S5: return TOK_OCT;
	case S6: return TOK_ESC;
	case S7: return TOK_HEX;
	default: 
				if (!has_consumed_input) { return TOK_EOF; }
				lx_ungetc(lx, c); lx->lgetc = NULL; return TOK_UNKNOWN;
	}

		if (lx->push != NULL) {
			if (-1 == lx->push(lx->buf_opaque, (char)c)) {
				return TOK_ERROR;
			}
		}

	lx->lgetc = NULL;

	if (!has_consumed_input) {
		return TOK_EOF;
	} 
	return TOK_ERROR;
}

static enum lx_token
z2(struct lx *lx)
{
	int has_consumed_input = 0;
	int c;

	assert(lx != NULL);

	if (lx->clear != NULL) {
		lx->clear(lx->buf_opaque);
	}

	lx->start = lx->end;

	void *getc_opaque = (void *)lx;
	enum {
		S0, S1, S2
	} state;

	state = S0;

	while (c = fsm_getc(getc_opaque), c != EOF) {
		has_consumed_input = 1;
		switch (state) {
		case S0: /* e.g. "" */
			switch ((unsigned char) c) {
			case '\'': state = S2; break;
			default: state = S1; break;
			}
			break;

		case S1: /* e.g. "" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_CHAR;

		case S2: /* e.g. "'" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return lx->z = z4, TOK_STR;

		default:
			; /* unreached */
		}
	}

	/* end states */
	switch (state) {
	case S1: return TOK_CHAR;
	case S2: return lx->z = z4, TOK_STR;
	default: 
				if (!has_consumed_input) { return TOK_EOF; }
				lx_ungetc(lx, c); lx->lgetc = NULL; return TOK_UNKNOWN;
	}

		if (lx->push != NULL) {
			if (-1 == lx->push(lx->buf_opaque, (char)c)) {
				return TOK_ERROR;
			}
		}

	lx->lgetc = NULL;

	if (!has_consumed_input) {
		return TOK_EOF;
	} 
	return TOK_ERROR;
}

static enum lx_token
z3(struct lx *lx)
{
	int has_consumed_input = 0;
	int c;

	assert(lx != NULL);

	if (lx->clear != NULL) {
		lx->clear(lx->buf_opaque);
	}

	lx->start = lx->end;

	void *getc_opaque = (void *)lx;
	enum {
		S0, S1, S2
	} state;

	state = S0;

	while (c = fsm_getc(getc_opaque), c != EOF) {
		has_consumed_input = 1;
		switch (state) {
		case S0: /* e.g. "" */
			switch ((unsigned char) c) {
			case '\n': state = S2; break;
			default: state = S1; break;
			}
			break;

		case S1: /* e.g. "" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return lx->z(lx);

		case S2: /* e.g. "" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return lx->z = z4, lx->z(lx);

		default:
			; /* unreached */
		}
	}

	/* end states */
	switch (state) {
	case S1: return TOK_UNKNOWN;
	case S2: return lx->z = z4, lx->z(lx);
	default: 
				if (!has_consumed_input) { return TOK_EOF; }
				lx_ungetc(lx, c); lx->lgetc = NULL; return TOK_UNKNOWN;
	}

		switch (state) {
		case S0:
		case S1:
		case S2:
			break;

		default:
			if (lx->push != NULL) {
				if (-1 == lx->push(lx->buf_opaque, (char)c)) {
					return TOK_ERROR;
				}
			}
			break;

		}

	lx->lgetc = NULL;

	if (!has_consumed_input) {
		return TOK_EOF;
	} 
	return TOK_ERROR;
}

static enum lx_token
z4(struct lx *lx)
{
	int has_consumed_input = 0;
	int c;

	assert(lx != NULL);

	if (lx->clear != NULL) {
		lx->clear(lx->buf_opaque);
	}

	lx->start = lx->end;

	void *getc_opaque = (void *)lx;
	enum {
		S0, S1, S2, S3, S4, S5, S6, S7, S8, S9, 
		S10, S11, S12, S13, S14, S15, S16, S17, S18, S19, 
		S20, S21, S22, S23, S24, S25, S26, S27, S28
	} state;

	state = S0;

	while (c = fsm_getc(getc_opaque), c != EOF) {
		has_consumed_input = 1;
		switch (state) {
		case S0: /* e.g. "" */
			switch ((unsigned char) c) {
			case ',': state = S1; break;
			case '$': state = S2; break;
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z': state = S3; break;
			case '&': state = S4; break;
			case '|': state = S5; break;
			case '.': state = S6; break;
			case '-': state = S7; break;
			case '\\': state = S8; break;
			case '^': state = S9; break;
			case '!': state = S10; break;
			case '~': state = S11; break;
			case '?': state = S12; break;
			case '+': state = S13; break;
			case '*': state = S14; break;
			case ')': state = S15; break;
			case '(': state = S16; break;
			case '}': state = S17; break;
			case '{': state = S18; break;
			case ';': state = S19; break;
			case '=': state = S20; break;
			case '/': state = S21; break;
			case '"': state = S22; break;
			case '\'': state = S23; break;
			case '#': state = S24; break;
			case '\t':
			case '\n':
			case '\r':
			case ' ': state = S25; break;
			default:  
				if (!has_consumed_input) { return TOK_EOF; }
				lx_ungetc(lx, c); lx->lgetc = NULL; return TOK_UNKNOWN;
			}
			break;

		case S1: /* e.g. "," */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_COMMA;

		case S2: /* e.g. "$" */
			switch ((unsigned char) c) {
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z': state = S28; break;
			default:  
				if (!has_consumed_input) { return TOK_EOF; }
				lx_ungetc(lx, c); lx->lgetc = NULL; return TOK_UNKNOWN;
			}
			break;

		case S3: /* e.g. "A" */
			switch ((unsigned char) c) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z': break;
			default:  lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_IDENT;
			}
			break;

		case S4: /* e.g. "&" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_AND;

		case S5: /* e.g. "|" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_PIPE;

		case S6: /* e.g. "." */
			switch ((unsigned char) c) {
			case '.': state = S27; break;
			default:  lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_DOT;
			}
			break;

		case S7: /* e.g. "-" */
			switch ((unsigned char) c) {
			case '>': state = S26; break;
			default:  lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_DASH;
			}
			break;

		case S8: /* e.g. "\\" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_DASH;

		case S9: /* e.g. "^" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_HAT;

		case S10: /* e.g. "!" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_BANG;

		case S11: /* e.g. "~" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_TILDE;

		case S12: /* e.g. "\077" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_QMARK;

		case S13: /* e.g. "+" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_CROSS;

		case S14: /* e.g. "*" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_STAR;

		case S15: /* e.g. ")" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_RPAREN;

		case S16: /* e.g. "(" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_LPAREN;

		case S17: /* e.g. "}" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_CLOSE;

		case S18: /* e.g. "{" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_OPEN;

		case S19: /* e.g. ";" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_SEMI;

		case S20: /* e.g. "=" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_BIND;

		case S21: /* e.g. "\057" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return lx->z = z0, lx->z(lx);

		case S22: /* e.g. "\"" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return lx->z = z1, lx->z(lx);

		case S23: /* e.g. "'" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return lx->z = z2, lx->z(lx);

		case S24: /* e.g. "#" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return lx->z = z3, lx->z(lx);

		case S25: /* e.g. "\\x09" */
			switch ((unsigned char) c) {
			case '\t':
			case '\n':
			case '\r':
			case ' ': break;
			default:  lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return lx->z(lx);
			}
			break;

		case S26: /* e.g. "->" */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_MAP;

		case S27: /* e.g. ".." */
			lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_TO;

		case S28: /* e.g. "$A" */
			switch ((unsigned char) c) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z': break;
			default:  lx_ungetc(lx, c); lx_dynpop(lx->buf_opaque); return TOK_TOKEN;
			}
			break;

		default:
			; /* unreached */
		}
	}

	/* end states */
	switch (state) {
	case S1: return TOK_COMMA;
	case S3: return TOK_IDENT;
	case S4: return TOK_AND;
	case S5: return TOK_PIPE;
	case S6: return TOK_DOT;
	case S7: return TOK_DASH;
	case S8: return TOK_DASH;
	case S9: return TOK_HAT;
	case S10: return TOK_BANG;
	case S11: return TOK_TILDE;
	case S12: return TOK_QMARK;
	case S13: return TOK_CROSS;
	case S14: return TOK_STAR;
	case S15: return TOK_RPAREN;
	case S16: return TOK_LPAREN;
	case S17: return TOK_CLOSE;
	case S18: return TOK_OPEN;
	case S19: return TOK_SEMI;
	case S20: return TOK_BIND;
	case S21: return lx->z = z0, lx->z(lx);
	case S22: return lx->z = z1, lx->z(lx);
	case S23: return lx->z = z2, lx->z(lx);
	case S24: return lx->z = z3, lx->z(lx);
	case S25: return TOK_EOF;
	case S26: return TOK_MAP;
	case S27: return TOK_TO;
	case S28: return TOK_TOKEN;
	default: 
				if (!has_consumed_input) { return TOK_EOF; }
				lx_ungetc(lx, c); lx->lgetc = NULL; return TOK_UNKNOWN;
	}

		switch (state) {
		case S21:
		case S22:
		case S23:
		case S24:
		case S25:
			break;

		default:
			if (lx->push != NULL) {
				if (-1 == lx->push(lx->buf_opaque, (char)c)) {
					return TOK_ERROR;
				}
			}
			break;

		}

	lx->lgetc = NULL;

	if (!has_consumed_input) {
		return TOK_EOF;
	} 
	return TOK_ERROR;
}

const char *
lx_name(enum lx_token t)
{
	switch (t) {
	case TOK_COMMA: return "COMMA";
	case TOK_TOKEN: return "TOKEN";
	case TOK_IDENT: return "IDENT";
	case TOK_AND: return "AND";
	case TOK_PIPE: return "PIPE";
	case TOK_DOT: return "DOT";
	case TOK_DASH: return "DASH";
	case TOK_HAT: return "HAT";
	case TOK_BANG: return "BANG";
	case TOK_TILDE: return "TILDE";
	case TOK_QMARK: return "QMARK";
	case TOK_CROSS: return "CROSS";
	case TOK_STAR: return "STAR";
	case TOK_RPAREN: return "RPAREN";
	case TOK_LPAREN: return "LPAREN";
	case TOK_CLOSE: return "CLOSE";
	case TOK_OPEN: return "OPEN";
	case TOK_MAP: return "MAP";
	case TOK_TO: return "TO";
	case TOK_SEMI: return "SEMI";
	case TOK_BIND: return "BIND";
	case TOK_RE: return "RE";
	case TOK_HEX: return "HEX";
	case TOK_OCT: return "OCT";
	case TOK_ESC: return "ESC";
	case TOK_CHAR: return "CHAR";
	case TOK_STR: return "STR";
	case TOK_EOF:     return "EOF";
	case TOK_ERROR:   return "ERROR";
	case TOK_UNKNOWN: return "UNKNOWN";
	default: return "?";
	}
}

const char *
lx_example(enum lx_token (*z)(struct lx *), enum lx_token t)
{
	assert(z != NULL);

	if (z == z0) {
		switch (t) {
		case TOK_COMMA: return "";
		case TOK_TOKEN: return "";
		case TOK_IDENT: return "";
		case TOK_AND: return "";
		case TOK_PIPE: return "";
		case TOK_DOT: return "";
		case TOK_DASH: return "";
		case TOK_HAT: return "";
		case TOK_BANG: return "";
		case TOK_TILDE: return "";
		case TOK_QMARK: return "";
		case TOK_CROSS: return "";
		case TOK_STAR: return "";
		case TOK_RPAREN: return "";
		case TOK_LPAREN: return "";
		case TOK_CLOSE: return "";
		case TOK_OPEN: return "";
		case TOK_MAP: return "";
		case TOK_TO: return "";
		case TOK_SEMI: return "";
		case TOK_BIND: return "";
		case TOK_RE: return "";
		case TOK_HEX: return "";
		case TOK_OCT: return "";
		case TOK_ESC: return "";
		case TOK_CHAR: return "";
		case TOK_STR: return "";
		default: goto error;
		}
	} else
	if (z == z1) {
		switch (t) {
		case TOK_COMMA: return "";
		case TOK_TOKEN: return "";
		case TOK_IDENT: return "";
		case TOK_AND: return "";
		case TOK_PIPE: return "";
		case TOK_DOT: return "";
		case TOK_DASH: return "";
		case TOK_HAT: return "";
		case TOK_BANG: return "";
		case TOK_TILDE: return "";
		case TOK_QMARK: return "";
		case TOK_CROSS: return "";
		case TOK_STAR: return "";
		case TOK_RPAREN: return "";
		case TOK_LPAREN: return "";
		case TOK_CLOSE: return "";
		case TOK_OPEN: return "";
		case TOK_MAP: return "";
		case TOK_TO: return "";
		case TOK_SEMI: return "";
		case TOK_BIND: return "";
		case TOK_RE: return "";
		case TOK_HEX: return "";
		case TOK_OCT: return "";
		case TOK_ESC: return "";
		case TOK_CHAR: return "";
		case TOK_STR: return "";
		default: goto error;
		}
	} else
	if (z == z2) {
		switch (t) {
		case TOK_COMMA: return "";
		case TOK_TOKEN: return "";
		case TOK_IDENT: return "";
		case TOK_AND: return "";
		case TOK_PIPE: return "";
		case TOK_DOT: return "";
		case TOK_DASH: return "";
		case TOK_HAT: return "";
		case TOK_BANG: return "";
		case TOK_TILDE: return "";
		case TOK_QMARK: return "";
		case TOK_CROSS: return "";
		case TOK_STAR: return "";
		case TOK_RPAREN: return "";
		case TOK_LPAREN: return "";
		case TOK_CLOSE: return "";
		case TOK_OPEN: return "";
		case TOK_MAP: return "";
		case TOK_TO: return "";
		case TOK_SEMI: return "";
		case TOK_BIND: return "";
		case TOK_RE: return "";
		case TOK_HEX: return "";
		case TOK_OCT: return "";
		case TOK_ESC: return "";
		case TOK_CHAR: return "";
		case TOK_STR: return "";
		default: goto error;
		}
	} else
	if (z == z3) {
		switch (t) {
		case TOK_COMMA: return "";
		case TOK_TOKEN: return "";
		case TOK_IDENT: return "";
		case TOK_AND: return "";
		case TOK_PIPE: return "";
		case TOK_DOT: return "";
		case TOK_DASH: return "";
		case TOK_HAT: return "";
		case TOK_BANG: return "";
		case TOK_TILDE: return "";
		case TOK_QMARK: return "";
		case TOK_CROSS: return "";
		case TOK_STAR: return "";
		case TOK_RPAREN: return "";
		case TOK_LPAREN: return "";
		case TOK_CLOSE: return "";
		case TOK_OPEN: return "";
		case TOK_MAP: return "";
		case TOK_TO: return "";
		case TOK_SEMI: return "";
		case TOK_BIND: return "";
		case TOK_RE: return "";
		case TOK_HEX: return "";
		case TOK_OCT: return "";
		case TOK_ESC: return "";
		case TOK_CHAR: return "";
		case TOK_STR: return "";
		default: goto error;
		}
	} else
	if (z == z4) {
		switch (t) {
		case TOK_COMMA: return "";
		case TOK_TOKEN: return "";
		case TOK_IDENT: return "";
		case TOK_AND: return "";
		case TOK_PIPE: return "";
		case TOK_DOT: return "";
		case TOK_DASH: return "";
		case TOK_HAT: return "";
		case TOK_BANG: return "";
		case TOK_TILDE: return "";
		case TOK_QMARK: return "";
		case TOK_CROSS: return "";
		case TOK_STAR: return "";
		case TOK_RPAREN: return "";
		case TOK_LPAREN: return "";
		case TOK_CLOSE: return "";
		case TOK_OPEN: return "";
		case TOK_MAP: return "";
		case TOK_TO: return "";
		case TOK_SEMI: return "";
		case TOK_BIND: return "";
		case TOK_RE: return "";
		case TOK_HEX: return "";
		case TOK_OCT: return "";
		case TOK_ESC: return "";
		case TOK_CHAR: return "";
		case TOK_STR: return "";
		default: goto error;
		}
	}

error:

	errno = EINVAL;
	return NULL;
}

void
lx_init(struct lx *lx)
{
	static const struct lx lx_default;

	assert(lx != NULL);

	*lx = lx_default;

	lx->c = EOF;
	lx->z = z4;

	lx->end.byte = 0;
	lx->end.line = 1;
	lx->end.col  = 1;
	(void)lx_dynpop;
}

enum lx_token
lx_next(struct lx *lx)
{
	enum lx_token t;

	assert(lx != NULL);
	assert(lx->z != NULL);

	if (lx->lgetc == NULL) {
		return TOK_EOF;
	}

	t = lx->z(lx);

	if (lx->push != NULL) {
		if (-1 == lx->push(lx->buf_opaque, '\0')) {
			return TOK_ERROR;
		}
	}

	return t;
}


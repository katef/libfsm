/*
 * Copyright 2008-2017 Katherine Flavel
 *
 * See LICENCE for the full copyright terms.
 */

#include <assert.h>
#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

#include "libfsm/internal.h" /* XXX: up here for bitmap.h */

#include <print/esc.h>

#include <adt/alloc.h>
#include <adt/set.h>
#include <adt/bitmap.h>
#include <adt/stateset.h>
#include <adt/edgeset.h>

#include <fsm/fsm.h>
#include <fsm/pred.h>
#include <fsm/walk.h>
#include <fsm/print.h>
#include <fsm/options.h>

static int
rangeclass(unsigned char x, unsigned char y)
{
	int (*a[])(int c) = { isupper, islower, isdigit };
	size_t i;

	for (i = 0; i < sizeof a / sizeof *a; i++) {
		if (a[i](x) && a[i](y)) {
			return 1;
		}
	}

	return 0;
}

static unsigned int
indexof(const struct fsm *fsm, const struct fsm_state *state)
{
	struct fsm_state *s;
	unsigned int i;

	assert(fsm != NULL);
	assert(state != NULL);

	for (s = fsm->sl, i = 0; s != NULL; s = s->next, i++) {
		if (s == state) {
			return i;
		}
	}

	assert(!"unreached");
	return 0;
}

void
fsm_print_api(FILE *f, const struct fsm *fsm)
{
	struct fsm_state *s, *start;
	struct bm *a; /* indexed by "to" state number */
	unsigned n;

	assert(f != NULL);
	assert(fsm != NULL);
	assert(fsm->opt != NULL);

/* TODO: leaf callback for opaques */

	if (fsm->opt->fragment) {
		fprintf(f, "\t");
	}
	fprintf(f, "/* Generated by libfsm */\n");
	fprintf(f, "\n");

	if (!fsm->opt->fragment) {
		fprintf(f, "#include LF_HEADER\n");
		fprintf(f, "\n");

		fprintf(f, "#include <stddef.h>\n");
		fprintf(f, "\n");

		fprintf(f, "#include <fsm/fsm.h>\n");
		fprintf(f, "\n");

		fprintf(f, "struct fsm *\n");
		fprintf(f, "%sfsm(const struct fsm_options *opt)\n",
			fsm->opt->prefix != NULL ? fsm->opt->prefix : "");

		fprintf(f, "{\n");
	}

	fprintf(f, "\tstruct fsm *fsm;\n");
	fprintf(f, "\tsize_t i;\n");
	fprintf(f, "\n");

	n = fsm_count(fsm, fsm_isany);
	fprintf(f, "\tstruct fsm_state *s[%u] = { 0 };\n", n);
	fprintf(f, "\n");

	fprintf(f, "\tfsm = fsm_new(opt);\n");
	fprintf(f, "\tif (fsm == NULL) {\n");
	fprintf(f, "\t\treturn NULL;\n");
	fprintf(f, "\t}\n");
	fprintf(f, "\n");

	fprintf(f, "\tfor (i = 0; i < %u; i++) {\n", n);
	fprintf(f, "\t\ts[i] = fsm_addstate(fsm);\n");
	fprintf(f, "\t\tif (s[i] == NULL) {\n");
	fprintf(f, "\t\t\tgoto error;\n");
	fprintf(f, "\t\t}\n");
	fprintf(f, "\t}\n");
	fprintf(f, "\n");

	a = f_malloc(fsm->opt->alloc, n * sizeof *a);
	if (a == NULL) {
		/* XXX */
		return;
	}

	for (s = fsm->sl; s != NULL; s = s->next) {
		struct fsm_edge *e;
		struct fsm_state *st;
		struct edge_iter it;
		struct state_iter jt;
		unsigned int from, to;
		unsigned int i;

		from = indexof(fsm, s);

		for (i = 0; i < n; i++) {
			bm_clear(&a[i]);
		}

		for (st = state_set_first(s->epsilons, &jt); st != NULL; st = state_set_next(&jt)) {
			assert(st != NULL);

			to = indexof(fsm, st);

			fprintf(f, "\tif (!fsm_addedge_epsilon(fsm, s[%u], s[%u])) { goto error; }\n",
				from, to);
		}

		for (e = edge_set_first(s->edges, &it); e != NULL; e = edge_set_next(&it)) {
			for (st = state_set_first(e->sl, &jt); st != NULL; st = state_set_next(&jt)) {
				assert(st != NULL);

				to = indexof(fsm, st);

				bm_set(&a[indexof(fsm, st)], e->symbol);
			}
		}

		for (i = 0; i < n; i++) {
			int hi, lo;

			to = i;

			hi = -1;

			for (;;) {
				/* start of range */
				lo = bm_next(&a[to], hi, 1);
				if (lo > UCHAR_MAX) {
						break;
				}

				/* one past the end of range */
				hi = bm_next(&a[to], lo, 0);

				if (lo == 0x00 && hi == UCHAR_MAX + 1) {
					fprintf(f, "\tif (!fsm_addedge_any(fsm, s[%u], s[%u]))",
						from, to);
					fprintf(f, " { goto error; }\n");
				} else if (lo == hi - 1) {
					fprintf(f, "\tif (!fsm_addedge_literal(fsm, s[%u], s[%u], ",
						from, to);
					c_escputcharlit(f, fsm->opt, lo);
					fprintf(f, ")) { goto error; }\n");
				} else {
					fprintf(f, "\tfor (i = 0x%02x; i <= 0x%02x; i++) {",
						(unsigned int) lo, (unsigned int) hi - 1);
					if (rangeclass(lo, hi - 1)) {
						fprintf(f, " /* '%c' .. '%c' */", (unsigned char) lo, (unsigned char) hi - 1);
					}
					fprintf(f, "\n");
					fprintf(f, "\t\tif (!fsm_addedge_literal(fsm, s[%u], s[%u], i))",
						from, to);
					fprintf(f, " { goto error; }\n");
					fprintf(f, "\t}\n");
				}
			}
		}
	}

	f_free(fsm->opt->alloc, a);

	fprintf(f, "\n");

	start = fsm_getstart(fsm);
	if (start == NULL) {
		return;
	}

	fprintf(f, "\tfsm_setstart(fsm, s[%u]);\n", indexof(fsm, start));

	for (s = fsm->sl; s != NULL; s = s->next) {
		if (fsm_isend(fsm, s)) {
			fprintf(f, "\tfsm_setend(fsm, s[%u], 1);\n", indexof(fsm, s));
		}
	}

	if (!fsm->opt->fragment) {
		fprintf(f, "\n");
		fprintf(f, "\treturn fsm;\n");

		fprintf(f, "\n");
		fprintf(f, "error:\n");
		fprintf(f, "\n");
		fprintf(f, "\tfsm_free(fsm);\n");
		fprintf(f, "\n");
		fprintf(f, "\treturn NULL;\n");

		fprintf(f, "}\n");
		fprintf(f, "\n");
	}
}


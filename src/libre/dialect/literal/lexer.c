/* Generated by lx */

#include <assert.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <errno.h>

#include LX_HEADER

static enum lx_literal_token z0(struct lx_literal_lx *lx);

static int
lx_literal_advance_end(struct lx_literal_lx *lx, int c)
{
	lx->end.byte++;
	lx->end.col++;
	if (c == '\n') {
		lx->end.line++;
		lx->end.saved_col = lx->end.col - 1;
		lx->end.col = 1;
	}
	if (lx->push != NULL) {
		if (-1 == lx->push(lx->buf_opaque, (char)c)) {
			return 0;
		}
	}
	return 1;
}

/* This wrapper manages one character of lookahead/pushback
 * and the line, column, and byte offsets. */
#if __STDC_VERSION__ >= 199901L
inline
#endif
static int
lx_literal_getc(struct lx_literal_lx *lx)
{
	int c;

	assert(lx != NULL);
	assert(lx->lgetc != NULL);

	if (lx->c != EOF) {
		c = lx->c, lx->c = EOF;
	} else {
		c = lx->lgetc(lx);
		if (c == EOF) {
			return EOF;
		}
	}

	if (!lx_literal_advance_end(lx, c)) { return EOF; }

	return c;
}

/* This wrapper adapts calling lx_literal_getc to the interface
 * in libfsm's generated code. */
static int
fsm_getc(void *getc_opaque)
{
	return lx_literal_getc((struct lx_literal_lx *)getc_opaque);
}

#if __STDC_VERSION__ >= 199901L
inline
#endif
static void
lx_literal_ungetc(struct lx_literal_lx *lx, int c)
{
	assert(lx != NULL);
	assert(lx->c == EOF);
	lx->c = c;
	lx->end.byte--;
	lx->end.col--;

	if (c == '\n') {
		lx->end.line--;
		lx->end.col = lx->end.saved_col;
	}
}

int
lx_literal_dynpush(void *buf_opaque, char c)
{
	struct lx_dynbuf *t = buf_opaque;

	assert(t != NULL);

	if (t->a == NULL || t->p == t->a + t->len) {
		size_t len;
		ptrdiff_t off;
		char *tmp;

		if (t->len == 0) {
			assert(LX_DYN_LOW > 0);
			len = LX_DYN_LOW;
		} else {
			len = t->len * LX_DYN_FACTOR;
			if (len < t->len) {
				errno = ERANGE;
				return -1;
			}
		}

		off = t->p - t->a;
		tmp = realloc(t->a, len);
		if (tmp == NULL) {
			return -1;
		}

		t->p   = tmp + off;
		t->a   = tmp;
		t->len = len;
	}

	assert(t->p != NULL);
	assert(t->a != NULL);

	*t->p++ = c;

	return 0;
}

static void
lx_literal_dynpop(void *buf_opaque)
{
	struct lx_dynbuf *t = buf_opaque;

	assert(t != NULL);

	assert(t->p != t->a);
	t->p--;
}

int
lx_literal_dynclear(void *buf_opaque)
{
	struct lx_dynbuf *t = buf_opaque;

	assert(t != NULL);

	if (t->len > LX_DYN_HIGH) {
		size_t len;
		char *tmp;

		len = t->len / LX_DYN_FACTOR;

		tmp = realloc(t->a, len);
		if (tmp == NULL) {
			return -1;
		}

		t->a   = tmp;
		t->len = len;
	}

	t->p = t->a;

	return 0;
}

void
lx_literal_dynfree(void *buf_opaque)
{
	struct lx_dynbuf *t = buf_opaque;

	assert(t != NULL);

	free(t->a);
}
static enum lx_literal_token
z0(struct lx_literal_lx *lx)
{
	int has_consumed_input = 0;
	int c;

	assert(lx != NULL);

	if (lx->clear != NULL) {
		lx->clear(lx->buf_opaque);
	}

	lx->start = lx->end;

	void *getc_opaque = (void *)lx;
	enum {
		S0, S1
	} state;

	state = S0;

	while (c = fsm_getc(getc_opaque), c != EOF) {
		has_consumed_input = 1;
		switch (state) {
		case S0: /* e.g. "" */
			state = S1; break;

		case S1: /* e.g. "" */
			lx_literal_ungetc(lx, c); lx_literal_dynpop(lx->buf_opaque); return TOK_CHAR;

		default:
			; /* unreached */
		}
	}

	/* end states */
	switch (state) {
	case S1: return TOK_CHAR;
	default: 
				if (!has_consumed_input) { return TOK_EOF; }
				lx_literal_ungetc(lx, c); lx->lgetc = NULL; return TOK_UNKNOWN;
	}

		if (lx->push != NULL) {
			if (-1 == lx->push(lx->buf_opaque, (char)c)) {
				return TOK_ERROR;
			}
		}

	lx->lgetc = NULL;

	if (!has_consumed_input) {
		return TOK_EOF;
	} 
	return TOK_ERROR;
}

const char *
lx_literal_name(enum lx_literal_token t)
{
	switch (t) {
	case TOK_CHAR: return "CHAR";
	case TOK_EOF:     return "EOF";
	case TOK_ERROR:   return "ERROR";
	case TOK_UNKNOWN: return "UNKNOWN";
	default: return "?";
	}
}

const char *
lx_literal_example(enum lx_literal_token (*z)(struct lx_literal_lx *), enum lx_literal_token t)
{
	assert(z != NULL);

	if (z == z0) {
		switch (t) {
		case TOK_CHAR: return "";
		default: goto error;
		}
	}

error:

	errno = EINVAL;
	return NULL;
}

void
lx_literal_init(struct lx_literal_lx *lx)
{
	static const struct lx_literal_lx lx_default;

	assert(lx != NULL);

	*lx = lx_default;

	lx->c = EOF;
	lx->z = z0;

	lx->end.byte = 0;
	lx->end.line = 1;
	lx->end.col  = 1;
	(void)lx_literal_dynpop;
}

enum lx_literal_token
lx_literal_next(struct lx_literal_lx *lx)
{
	enum lx_literal_token t;

	assert(lx != NULL);
	assert(lx->z != NULL);

	if (lx->lgetc == NULL) {
		return TOK_EOF;
	}

	t = lx->z(lx);

	if (lx->push != NULL) {
		if (-1 == lx->push(lx->buf_opaque, '\0')) {
			return TOK_ERROR;
		}
	}

	return t;
}

